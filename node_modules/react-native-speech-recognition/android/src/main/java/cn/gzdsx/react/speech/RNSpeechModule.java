package cn.gzdsx.react.speech;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import android.Manifest;
import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.Handler;
import android.provider.Settings;
import android.speech.RecognizerIntent;
import android.speech.SpeechRecognizer;
import android.speech.RecognitionListener;
import android.speech.RecognitionService;
import android.util.Log;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.RCTNativeAppEventEmitter;

import java.util.List;
import java.util.Locale;

public class RNSpeechModule extends ReactContextBaseJavaModule implements RNSpeechRecognitionDelegate {
    final String TAG = "RNSpeech";
    ReactApplicationContext mContext;
    SpeechRecognizer mSpeechRecognizer;

    Callback mCallback;
    Callback errCallback;
    Handler mHandler;

    public RNSpeechModule(@Nullable ReactApplicationContext reactContext) {
        super(reactContext);
        mContext = reactContext;
        mHandler = new Handler(reactContext.getMainLooper());
    }

    @NonNull
    @Override
    public String getName() {
        return "RNSpeech";
    }

    private void createSpeechRecognizer() {
        if (mSpeechRecognizer != null) {
            mSpeechRecognizer.cancel();
            mSpeechRecognizer.destroy();
            mSpeechRecognizer = null;
        }

        // 内置语音识别服务是否可用
        boolean isRecognizerServiceValid = false;
        ComponentName currentRecognitionCmp = null;
        // 查找得到的 "可用的" 语音识别服务
        String serviceComponent = Settings.Secure.getString(mContext.getContentResolver(), "voice_recognition_service");
        Log.d(TAG, serviceComponent);
        ComponentName component = ComponentName.unflattenFromString(serviceComponent);
        List<ResolveInfo> list = mContext.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE), PackageManager.MATCH_ALL);

        if (list != null && list.size() != 0) {
            for (ResolveInfo info : list) {
                Log.d(TAG, info.loadLabel(mContext.getPackageManager()) + ": "
                        + info.serviceInfo.packageName + "/" + info.serviceInfo.name);

                // 这里拿系统使用的语音识别服务和内置的语音识别比较，如果相同，OK我们直接直接使用
                // 如果相同就可以直接使用mSpeechRecognizer = SpeechRecognizer.createSpeechRecognizer(context);来创建实例，因为内置的可以使用
                if (info.serviceInfo.packageName.equals(component.getPackageName())) {
                    isRecognizerServiceValid = true;
                    break;
                } else {
                    // 如果服务不同，说明 内置服务 和 系统使用 不是同一个，那么我们需要使用系统使用的
                    // 因为内置的系统不用，我们用了也没有用
                    currentRecognitionCmp = new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
                }
            }
        } else {
            // 这里既是查不到可用的语音识别服务，可以歇菜了
            Log.d(TAG, "No recognition services installed");
            return;
        }

        // 当前系统内置语音识别服务可用
        if (isRecognizerServiceValid) {
            mSpeechRecognizer = SpeechRecognizer.createSpeechRecognizer(mContext);
        } else {
            // 内置不可用，需要我们使用查找到的可用的
            mSpeechRecognizer = SpeechRecognizer.createSpeechRecognizer(mContext, currentRecognitionCmp);
        }
        mSpeechRecognizer.setRecognitionListener(new RNSpeechRecognitionListener(
                this,
                mContext.getJSModule(RCTNativeAppEventEmitter.class)
        ));
    }

    private Intent createIntent() {
        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        intent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 3)
                .putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
                .putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.CHINESE.toString())
                .putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
        return intent;
    }

    @ReactMethod
    public void startRecord() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (SpeechRecognizer.isRecognitionAvailable(mContext)) {
                    Log.d(TAG, "开始录音");
                    createSpeechRecognizer();
                    mSpeechRecognizer.startListening(createIntent());
                } else {
                    Log.d(TAG, "语音识别服务不可用");
                    WritableMap errMap = Arguments.createMap();
                    errMap.putInt("code", 1);
                    errMap.putString("message", "语音识别服务不可用");
                    mContext.getJSModule(RCTNativeAppEventEmitter.class).emit("onError", errMap);
                }
            }
        });
    }

    @ReactMethod
    public void stopRecord(Callback callback) {
        mCallback = callback;
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (mSpeechRecognizer != null) {
                    mSpeechRecognizer.stopListening();
                }
            }
        });
    }

    @ReactMethod
    public void requestAuthorization(Callback callback) {
        String permission = Manifest.permission.RECORD_AUDIO;
        Activity activity = mContext.getCurrentActivity();
        if (activity != null) {
            activity.requestPermissions(new String[]{permission}, 0);
        }
        if (callback != null) {
            callback.invoke();
        }
    }

    @Override
    public void onResult(String result) {
        if (mCallback != null) {
            mCallback.invoke(result);
        }
    }
}