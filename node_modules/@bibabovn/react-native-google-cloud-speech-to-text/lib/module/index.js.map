{"version":3,"sources":["index.tsx"],"names":["NativeModules","NativeEventEmitter","GoogleCloudSpeechToText","VoiceEmitter","GCSpeechToText","constructor","_listeners","_events","onSpeech","undefined","onSpeechEnd","onSpeechError","onSpeechStart","onSpeechRecognized","start","Object","keys","map","key","addListener","stop","setApiKey","apiKey","removeListeners","listener","remove","destroy","fn"],"mappings":";;AAAA,SAASA,aAAT,EAAwBC,kBAAxB,QAAkD,cAAlD;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAA8BF,aAApC;AAEA,MAAMG,YAAY,GAAG,IAAIF,kBAAJ,CAAuBC,uBAAvB,CAArB;;AAkCA,MAAME,cAAN,CAAqB;AAInBC,EAAAA,WAAW,GAAG;AAAA;;AAAA;;AACZ,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,OAAL,GAAe;AACbC,MAAAA,QAAQ,EAAE,MAAMC,SADH;AAEbC,MAAAA,WAAW,EAAE,MAAMD,SAFN;AAGbE,MAAAA,aAAa,EAAE,MAAMF,SAHR;AAIbG,MAAAA,aAAa,EAAE,MAAMH,SAJR;AAKbI,MAAAA,kBAAkB,EAAE,MAAMJ;AALb,KAAf;AAOD;;AAED,QAAMK,KAAN,GAA6B;AAC3B,QAAI,CAAC,KAAKR,UAAV,EAAsB;AACpB,WAAKA,UAAL,GAAmBS,MAAM,CAACC,IAAP,CACjB,KAAKT,OADY,CAAD,CAEEU,GAFF,CAEOC,GAAD,IACtBf,YAAY,CAACgB,WAAb,CAAyBD,GAAzB,EAA8B,KAAKX,OAAL,CAAaW,GAAb,CAA9B,CAHgB,CAAlB;AAKD;;AAED,WAAO,MAAMhB,uBAAuB,CAACY,KAAxB,EAAb;AACD;;AAED,QAAMM,IAAN,GAA4B;AAC1B,UAAMlB,uBAAuB,CAACkB,IAAxB,EAAN;AACD;;AAEDC,EAAAA,SAAS,CAACC,MAAD,EAAuB;AAC9BpB,IAAAA,uBAAuB,CAACmB,SAAxB,CAAkCC,MAAlC;AACD;;AAED,QAAMC,eAAN,GAAuC;AACrC,QAAI,KAAKjB,UAAT,EAAqB;AACnB,WAAKA,UAAL,CAAgBW,GAAhB,CAAqBO,QAAD,IAAcA,QAAQ,CAACC,MAAT,EAAlC;;AACA,WAAKnB,UAAL,GAAkB,IAAlB;AACD;;AACD,SAAKA,UAAL,GAAkB,IAAlB;AACA,UAAMJ,uBAAuB,CAACwB,OAAxB,EAAN;AACD;;AAEDd,EAAAA,aAAa,CAACe,EAAD,EAAuC;AAClD,SAAKpB,OAAL,CAAaK,aAAb,GAA6Be,EAA7B;AACD;;AAEDnB,EAAAA,QAAQ,CAACmB,EAAD,EAAoC;AAC1C,SAAKpB,OAAL,CAAaC,QAAb,GAAwBmB,EAAxB;AACD;;AAEDjB,EAAAA,WAAW,CAACiB,EAAD,EAAiB;AAC1B,SAAKpB,OAAL,CAAaG,WAAb,GAA2BiB,EAA3B;AACD;;AAEDhB,EAAAA,aAAa,CAACgB,EAAD,EAAwC;AACnD,SAAKpB,OAAL,CAAaI,aAAb,GAA6BgB,EAA7B;AACD;;AAEDd,EAAAA,kBAAkB,CAACc,EAAD,EAA4C;AAC5D,SAAKpB,OAAL,CAAaM,kBAAb,GAAkCc,EAAlC;AACD;;AA9DkB;;AAiErB,eAAe,IAAIvB,cAAJ,EAAf","sourcesContent":["import { NativeModules, NativeEventEmitter } from 'react-native';\n\nconst { GoogleCloudSpeechToText } = NativeModules;\n\nconst VoiceEmitter = new NativeEventEmitter(GoogleCloudSpeechToText);\n\ntype SpeechEvent = keyof SpeechEvents;\n\nexport interface SpeechEvents {\n  onSpeechStart?: (e: SpeechStartEvent) => void;\n  onSpeech?: (e: OnSpeechEvent) => void;\n  onSpeechEnd?: () => void;\n  onSpeechError?: (e: SpeechErrorEvent) => void;\n\n  onSpeechRecognized?: (e: SpeechRecognizedEvent) => void;\n}\n\nexport interface SpeechStartEvent {\n  sampleRate: number;\n  state: number;\n}\n\nexport interface OnSpeechEvent {\n  size: number;\n}\n\nexport interface SpeechErrorEvent {\n  error?: {\n    code?: string;\n    message?: string;\n  };\n}\n\nexport interface SpeechRecognizedEvent {\n  isFinal: boolean;\n  transcript: string;\n}\n\nclass GCSpeechToText {\n  private readonly _events: Required<SpeechEvents>;\n  private _listeners: any[] | null;\n\n  constructor() {\n    this._listeners = null;\n    this._events = {\n      onSpeech: () => undefined,\n      onSpeechEnd: () => undefined,\n      onSpeechError: () => undefined,\n      onSpeechStart: () => undefined,\n      onSpeechRecognized: () => undefined,\n    };\n  }\n\n  async start(): Promise<void> {\n    if (!this._listeners) {\n      this._listeners = (Object.keys(\n        this._events\n      ) as SpeechEvent[]).map((key) =>\n        VoiceEmitter.addListener(key, this._events[key])\n      );\n    }\n\n    return await GoogleCloudSpeechToText.start();\n  }\n\n  async stop(): Promise<void> {\n    await GoogleCloudSpeechToText.stop();\n  }\n\n  setApiKey(apiKey: string): void {\n    GoogleCloudSpeechToText.setApiKey(apiKey);\n  }\n\n  async removeListeners(): Promise<void> {\n    if (this._listeners) {\n      this._listeners.map((listener) => listener.remove());\n      this._listeners = null;\n    }\n    this._listeners = null;\n    await GoogleCloudSpeechToText.destroy();\n  }\n\n  onSpeechStart(fn: (data: SpeechStartEvent) => void) {\n    this._events.onSpeechStart = fn;\n  }\n\n  onSpeech(fn: (data: OnSpeechEvent) => void) {\n    this._events.onSpeech = fn;\n  }\n\n  onSpeechEnd(fn: () => void) {\n    this._events.onSpeechEnd = fn;\n  }\n\n  onSpeechError(fn: (error: SpeechErrorEvent) => void) {\n    this._events.onSpeechError = fn;\n  }\n\n  onSpeechRecognized(fn: (data: SpeechRecognizedEvent) => void) {\n    this._events.onSpeechRecognized = fn;\n  }\n}\n\nexport default new GCSpeechToText();\n"]}