function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { NativeModules, NativeEventEmitter } from 'react-native';
const {
  GoogleCloudSpeechToText
} = NativeModules;
const VoiceEmitter = new NativeEventEmitter(GoogleCloudSpeechToText);

class GCSpeechToText {
  constructor() {
    _defineProperty(this, "_events", void 0);

    _defineProperty(this, "_listeners", void 0);

    this._listeners = null;
    this._events = {
      onSpeech: () => undefined,
      onSpeechEnd: () => undefined,
      onSpeechError: () => undefined,
      onSpeechStart: () => undefined,
      onSpeechRecognized: () => undefined
    };
  }

  async start() {
    if (!this._listeners) {
      this._listeners = Object.keys(this._events).map(key => VoiceEmitter.addListener(key, this._events[key]));
    }

    return await GoogleCloudSpeechToText.start();
  }

  async stop() {
    await GoogleCloudSpeechToText.stop();
  }

  setApiKey(apiKey) {
    GoogleCloudSpeechToText.setApiKey(apiKey);
  }

  async removeListeners() {
    if (this._listeners) {
      this._listeners.map(listener => listener.remove());

      this._listeners = null;
    }

    this._listeners = null;
    await GoogleCloudSpeechToText.destroy();
  }

  onSpeechStart(fn) {
    this._events.onSpeechStart = fn;
  }

  onSpeech(fn) {
    this._events.onSpeech = fn;
  }

  onSpeechEnd(fn) {
    this._events.onSpeechEnd = fn;
  }

  onSpeechError(fn) {
    this._events.onSpeechError = fn;
  }

  onSpeechRecognized(fn) {
    this._events.onSpeechRecognized = fn;
  }

}

export default new GCSpeechToText();
//# sourceMappingURL=index.js.map