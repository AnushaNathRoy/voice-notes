"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactNative = require("react-native");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const {
  GoogleCloudSpeechToText
} = _reactNative.NativeModules;
const VoiceEmitter = new _reactNative.NativeEventEmitter(GoogleCloudSpeechToText);

class GCSpeechToText {
  constructor() {
    _defineProperty(this, "_events", void 0);

    _defineProperty(this, "_listeners", void 0);

    this._listeners = null;
    this._events = {
      onSpeech: () => undefined,
      onSpeechEnd: () => undefined,
      onSpeechError: () => undefined,
      onSpeechStart: () => undefined,
      onSpeechRecognized: () => undefined
    };
  }

  async start() {
    if (!this._listeners) {
      this._listeners = Object.keys(this._events).map(key => VoiceEmitter.addListener(key, this._events[key]));
    }

    return await GoogleCloudSpeechToText.start();
  }

  async stop() {
    await GoogleCloudSpeechToText.stop();
  }

  setApiKey(apiKey) {
    GoogleCloudSpeechToText.setApiKey(apiKey);
  }

  async removeListeners() {
    if (this._listeners) {
      this._listeners.map(listener => listener.remove());

      this._listeners = null;
    }

    this._listeners = null;
    await GoogleCloudSpeechToText.destroy();
  }

  onSpeechStart(fn) {
    this._events.onSpeechStart = fn;
  }

  onSpeech(fn) {
    this._events.onSpeech = fn;
  }

  onSpeechEnd(fn) {
    this._events.onSpeechEnd = fn;
  }

  onSpeechError(fn) {
    this._events.onSpeechError = fn;
  }

  onSpeechRecognized(fn) {
    this._events.onSpeechRecognized = fn;
  }

}

var _default = new GCSpeechToText();

exports.default = _default;
//# sourceMappingURL=index.js.map